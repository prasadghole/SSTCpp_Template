/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "sst.hpp"           // SST framework
#include "sst_port.hpp"
#include "bsp.hpp"
#include "LED_AO.hpp"
#include "gpio.h"
#include "stm32f3xx.h"

static void System_Init(void);

LED_AO LEDAO;
//............................................................................
int main()
{
  SST::init(); // initialize the SST kernel
  System_Init();

  static SST::Evt const * ledeventSto[10];
  LEDAO.start(1u, ledeventSto, ARRAY_NELEM(ledeventSto), nullptr);

  return SST::Task::run();


}

static void System_Init(void)
{

  /* Configure the MPU to prevent NULL-pointer dereferencing
   * see: www.state-machine.com/null-pointer-protection-with-arm-cortex-m-mpu
   */
  MPU->RBAR = 0x0U /* base address (NULL) */
  | MPU_RBAR_VALID_Msk /* valid region */
  | (MPU_RBAR_REGION_Msk & 7U); /* region #7 */
  MPU->RASR = (7U << MPU_RASR_SIZE_Pos) /* 2^(7+1) region */
  | (0x0U << MPU_RASR_AP_Pos) /* no-access region */
  | MPU_RASR_ENABLE_Msk; /* region enable */

  MPU->CTRL = MPU_CTRL_PRIVDEFENA_Msk /* enable background region */
  | MPU_CTRL_ENABLE_Msk; /* enable the MPU */
  __ISB();
  __DSB();

  /* repurpose regular IRQs for SST Tasks */
  LEDAO.setIRQ(PVD_IRQn);

  MX_GPIO_Init();

}


namespace SST {

void onStart(void) {
    SystemCoreClockUpdate();

    // set up the SysTick timer to fire at BSP::TICKS_PER_SEC rate
    SysTick_Config((SystemCoreClock / BSP::TICKS_PER_SEC) + 1U);

    // set priorities of ISRs used in the system
    NVIC_SetPriority(SysTick_IRQn, 0U);
    // ...
}
//............................................................................
void onIdle(void) {
#ifdef NDEBUG
    // Put the CPU and peripherals to the low-power mode.
    // you might need to customize the clock management for your application,
    // see the datasheet for your particular Cortex-M MCU.
    //
    __WFI(); // Wait-For-Interrupt
#endif
}
}
extern "C"
{
void DBC_fault_handler(char const *const module, int const label)
{
}
}
